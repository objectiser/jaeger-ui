(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"), require("react-dom"));
	else if(typeof define === 'function' && define.amd)
		define(["react", "react-dom"], factory);
	else if(typeof exports === 'object')
		exports["ReactMetrics"] = factory(require("react"), require("react-dom"));
	else
		root["ReactMetrics"] = factory(root["React"], root["ReactDOM"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_7__, __WEBPACK_EXTERNAL_MODULE_15__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.PropTypes = exports.MetricsElement = exports.exposeMetrics = exports.metrics = exports.createMetrics = undefined;

	var _createMetrics = __webpack_require__(9);

	var _createMetrics2 = _interopRequireDefault(_createMetrics);

	var _metrics = __webpack_require__(24);

	var _metrics2 = _interopRequireDefault(_metrics);

	var _PropTypes = __webpack_require__(2);

	var _PropTypes2 = _interopRequireDefault(_PropTypes);

	var _exposeMetrics = __webpack_require__(12);

	var _exposeMetrics2 = _interopRequireDefault(_exposeMetrics);

	var _MetricsElement = __webpack_require__(19);

	var _MetricsElement2 = _interopRequireDefault(_MetricsElement);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.createMetrics = _createMetrics2.default;
	exports.metrics = _metrics2.default;
	exports.exposeMetrics = _exposeMetrics2.default;
	exports.MetricsElement = _MetricsElement2.default;
	exports.PropTypes = _PropTypes2.default;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */

	var validateFormat = function validateFormat(format) {};

	if (true) {
	  validateFormat = function validateFormat(format) {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  };
	}

	function invariant(condition, format, a, b, c, d, e, f) {
	  validateFormat(format);

	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }

	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	}

	module.exports = invariant;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.location = exports.metrics = undefined;

	var _propTypes = __webpack_require__(6);

	var metrics = exports.metrics = _propTypes.object;

	var location = exports.location = (0, _propTypes.shape)({
	    pathname: _propTypes.string.isRequired,
	    search: _propTypes.string.isRequired,
	    query: _propTypes.object,
	    state: _propTypes.object
	});

	exports.default = {
	    metrics: metrics,
	    location: location
	};

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var emptyFunction = __webpack_require__(5);

	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */

	var warning = emptyFunction;

	if (true) {
	  (function () {
	    var printWarning = function printWarning(format) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }

	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // --- Welcome to debugging React ---
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    };

	    warning = function warning(condition, format) {
	      if (format === undefined) {
	        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	      }

	      if (format.indexOf('Failed Composite propType: ') === 0) {
	        return; // Ignore CompositeComponent proptype check.
	      }

	      if (!condition) {
	        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	          args[_key2 - 2] = arguments[_key2];
	        }

	        printWarning.apply(undefined, [format].concat(args));
	      }
	    };
	  })();
	}

	module.exports = warning;

/***/ }),
/* 4 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

	/**
	 * Simple, lightweight module assisting with the detection and context of
	 * Worker. Helps avoid circular dependencies and allows code to reason about
	 * whether or not they are in a Worker, even if they never include the main
	 * `ReactWorker` dependency.
	 */
	var ExecutionEnvironment = {

	  canUseDOM: canUseDOM,

	  canUseWorkers: typeof Worker !== 'undefined',

	  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

	  canUseViewport: canUseDOM && !!window.screen,

	  isInWorker: !canUseDOM // For now, this is true - might change in the future.

	};

	module.exports = ExecutionEnvironment;

/***/ }),
/* 5 */
/***/ (function(module, exports) {

	"use strict";

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}

	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	var emptyFunction = function emptyFunction() {};

	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};

	module.exports = emptyFunction;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */

	if (true) {
	  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
	    Symbol.for &&
	    Symbol.for('react.element')) ||
	    0xeac7;

	  var isValidElement = function(object) {
	    return typeof object === 'object' &&
	      object !== null &&
	      object.$$typeof === REACT_ELEMENT_TYPE;
	  };

	  // By explicitly using `prop-types` you are opting into new development behavior.
	  // http://fb.me/prop-types-in-prod
	  var throwOnDirectAccess = true;
	  module.exports = __webpack_require__(31)(isValidElement, throwOnDirectAccess);
	} else {
	  // By explicitly using `prop-types` you are opting into new production behavior.
	  // http://fb.me/prop-types-in-prod
	  module.exports = require('./factoryWithThrowingShims')();
	}


/***/ }),
/* 7 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_7__;

/***/ }),
/* 8 */
/***/ (function(module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 * Type of default actions supported by metrics
	 *
	 * @module ActionTypes
	 * @internal
	 */
	var ActionTypes = {
	  PAGE_VIEW: "pageView", // request page view track
	  TRACK: "track" // request custom link track
	};

	exports.default = ActionTypes;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Metrics = undefined;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	exports.isMetrics = isMetrics;
	exports.default = createMetrics;

	var _eventemitter = __webpack_require__(28);

	var _eventemitter2 = _interopRequireDefault(_eventemitter);

	var _querystring = __webpack_require__(34);

	var _querystring2 = _interopRequireDefault(_querystring);

	var _ExecutionEnvironment = __webpack_require__(4);

	var _invariant = __webpack_require__(1);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _warning = __webpack_require__(3);

	var _warning2 = _interopRequireDefault(_warning);

	var _ActionTypes = __webpack_require__(8);

	var _ActionTypes2 = _interopRequireDefault(_ActionTypes);

	var _createService = __webpack_require__(16);

	var _createService2 = _interopRequireDefault(_createService);

	var _extractApis = __webpack_require__(11);

	var _extractApis2 = _interopRequireDefault(_extractApis);

	var _isPromise = __webpack_require__(18);

	var _isPromise2 = _interopRequireDefault(_isPromise);

	var _useTrackBindingPlugin = __webpack_require__(10);

	var _useTrackBindingPlugin2 = _interopRequireDefault(_useTrackBindingPlugin);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var qs = _ExecutionEnvironment.canUseDOM ? _querystring2.default.decode(window.location.search.substr(1)) : {};
	var defaults = {
	    pageViewEvent: "pageLoad",
	    pageDefaults: function pageDefaults() {
	        return {};
	    },
	    requestTimeout: 15 * 1000
	};

	var Transaction = function () {
	    function Transaction() {
	        _classCallCheck(this, Transaction);

	        this.pvTransactions = {};
	        this.transactionId = 0;
	    }

	    _createClass(Transaction, [{
	        key: "create",
	        value: function create() {
	            return ++this.transactionId;
	        }
	    }, {
	        key: "current",
	        value: function current() {
	            return this.transactionId;
	        }
	    }, {
	        key: "get",
	        value: function get(tId) {
	            return this.pvTransactions[tId];
	        }
	    }, {
	        key: "set",
	        value: function set(tId, value) {
	            this.pvTransactions[tId] = value;
	        }
	    }, {
	        key: "remove",
	        value: function remove(tId) {
	            if (tId && this.pvTransactions[tId]) {
	                delete this.pvTransactions[tId];
	            }
	        }
	    }, {
	        key: "keys",
	        value: function keys() {
	            return Object.keys(this.pvTransactions);
	        }
	    }]);

	    return Transaction;
	}();

	var Metrics = exports.Metrics = function (_EventEmitter) {
	    _inherits(Metrics, _EventEmitter);

	    function Metrics() {
	        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	        _classCallCheck(this, Metrics);

	        if (!options.vendors) {
	            throw new Error("'vendors' option is required.");
	        }

	        var _this = _possibleConstructorReturn(this, (Metrics.__proto__ || Object.getPrototypeOf(Metrics)).call(this));

	        _this.enabled = options.enabled !== false;
	        // undocumented option for unit test.
	        _this.canUseDOM = options.canUseDOM !== undefined ? !!options.canUseDOM : _ExecutionEnvironment.canUseDOM;
	        if (!_this.canUseDOM) {
	            _this.enabled = false;
	        }
	        _this.debug = !!options.debug || qs.metrics_debug === "true";
	        _this.customParams = options.customParams || {};
	        _this.pageDefaults = options.pageDefaults || defaults.pageDefaults;
	        _this.pageViewEvent = options.pageViewEvent || defaults.pageViewEvent;
	        _this.requestTimeout = options.requestTimeout || defaults.requestTimeout;
	        _this.cancelOnNext = options.cancelOnNext !== undefined ? !!options.cancelOnNext : true;
	        _this.vendors = Array.isArray(options.vendors) ? options.vendors : [options.vendors];
	        _this.services = _this.vendors.map(function (vendor) {
	            return (0, _createService2.default)(vendor);
	        });
	        _this.apiList = (0, _extractApis2.default)(_this.services.map(function (service) {
	            return service.apis;
	        }));
	        _this.transaction = new Transaction();
	        _this.routeState = {};
	        _this.apiImpl = _this.apiList.reduce(function (impl, api) {
	            impl[api] = function () {
	                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	                    args[_key] = arguments[_key];
	                }

	                return _this._prepareTrack.apply(_this, [api].concat(args));
	            };
	            return impl;
	        }, {});
	        Object.freeze(_this.apiImpl);
	        return _this;
	    }

	    _createClass(Metrics, [{
	        key: "listen",
	        value: function listen(type, callback) {
	            var _this2 = this;

	            // if type is not specified, listen for all the apis.
	            if (typeof type === "function") {
	                callback = type;
	                type = null;
	            }

	            if (type) {
	                this.on(type, callback);
	            } else {
	                this.apiList.forEach(function (api) {
	                    _this2.on(api, callback);
	                });
	            }

	            return function () {
	                if (type) {
	                    _this2.removeListener(type, callback);
	                } else {
	                    _this2.apiList.forEach(function (api) {
	                        _this2.removeListener(api, callback);
	                    });
	                }
	            };
	        }
	    }, {
	        key: "setRouteState",
	        value: function setRouteState(state) {
	            this._cancelPreviousPromiseIfPending();
	            this.routeState = state;
	        }

	        /* eslint-disable consistent-return */

	    }, {
	        key: "useTrackBinding",
	        value: function useTrackBinding(rootElement, attributePrefix) {
	            if (!this.enabled) {
	                return;
	            }

	            // if 'false' is passed as first param, detach listeners
	            if (rootElement === false) {
	                this._removeTrackBindingListener();
	                return;
	            }

	            (0, _invariant2.default)(typeof this.api.track === "function", "Metrics 'track' method needs to be defined for declarative tracking.");

	            if (this._trackBindingListener) {
	                this._removeTrackBindingListener();
	            }

	            this._trackBindingListener = (0, _useTrackBindingPlugin2.default)({
	                callback: this._handleClick.bind(this),
	                rootElement: rootElement,
	                attributePrefix: attributePrefix
	            });

	            return this._removeTrackBindingListener.bind(this);
	        }
	    }, {
	        key: "destroy",
	        value: function destroy() {
	            this._removeListeners();
	            this._removeTrackBindingListener();
	        }
	    }, {
	        key: "_callServices",

	        /**
	         * @method _callServices
	         * @param type
	         * @param promise
	         * @returns {Promise.<T>}
	         * @private
	         */
	        value: function _callServices(type, promise) {
	            var _this3 = this;

	            return promise.then(function (params) {
	                var results = [];
	                var services = _this3.services;
	                var requestTimeout = _this3.requestTimeout;

	                function isCompleted() {
	                    return results.length === services.length;
	                }

	                function clearTimer(timer) {
	                    if (timer) {
	                        clearTimeout(timer);
	                        timer = null;
	                    }
	                }

	                return new Promise(function (resolve) {
	                    function process(result) {
	                        if (this.isTimeout) {
	                            return;
	                        }
	                        this.isTimeout = true;
	                        clearTimer(this.timer);
	                        results.push(result);
	                        if (isCompleted()) {
	                            resolve(results);
	                        }
	                    }

	                    services.map(function (service) {
	                        var apis = service.apis,
	                            name = service.name;

	                        var apiExists = apis && apis[type];
	                        if (apiExists) {
	                            (0, _warning2.default)(typeof apis[type] === "function", "'" + type + "'" + (name ? "(" + name + " Service)" : "") + " is not a function");
	                        }
	                        var requestPromise = apiExists && typeof apis[type] === "function" ? apis[type].apply(apis, _toConsumableArray(params)) : undefined;
	                        if (!(0, _isPromise2.default)(requestPromise)) {
	                            requestPromise = Promise.resolve(requestPromise);
	                        }
	                        requestPromise.isTimeout = false;
	                        requestPromise.timer = setTimeout(process.bind(requestPromise), requestTimeout, {
	                            name: name,
	                            params: params,
	                            error: new Error("Request time out after " + requestTimeout + " ms."),
	                            status: "failure"
	                        });
	                        return requestPromise.then(function (response) {
	                            return {
	                                name: name,
	                                params: params,
	                                response: response,
	                                status: "success"
	                            };
	                        }).catch(function (error) {
	                            return {
	                                name: name,
	                                params: params,
	                                error: error,
	                                status: "failure"
	                            };
	                        }).then(process.bind(requestPromise));
	                    });
	                });
	            });
	        }
	        /**
	         * Cancels page view promise if it's still pending while the route has changed.
	         *
	         * @method _cancelPreviousPromiseIfPending
	         * @private
	         */

	    }, {
	        key: "_cancelPreviousPromiseIfPending",
	        value: function _cancelPreviousPromiseIfPending() {
	            var _this4 = this;

	            this.routeState = {};
	            this.transaction.keys().forEach(function (tId) {
	                var entry = _this4.transaction.get(tId);
	                if (entry && entry.cancelOnNext) {
	                    entry.shouldCancel = true;
	                }
	            });
	        }

	        /**
	         * @method _createTransaction
	         * @param args
	         * @private
	         */

	    }, {
	        key: "_createTransaction",
	        value: function _createTransaction(args) {
	            var tId = this.transaction.current();
	            var cancelOnNext = this.cancelOnNext;
	            this.transaction.set(tId, {
	                promise: args[0],
	                cancelOnNext: cancelOnNext
	            });
	            args.push(tId);
	        }
	        /**
	         * @method _clearTransaction
	         * @param tId
	         * @private
	         */

	    }, {
	        key: "_clearTransaction",
	        value: function _clearTransaction(tId) {
	            this.transaction.remove(tId);
	        }
	        /**
	         * @method _doTrack
	         * @param type
	         * @param promise
	         * @param tId
	         * @private
	         */

	    }, {
	        key: "_doTrack",
	        value: function _doTrack(type, promise, tId) {
	            promise = this._callServices(type, promise);
	            var dispatchEvent = function (status, response, error) {
	                var eventFacade = {
	                    type: type,
	                    status: status
	                };
	                if (response) {
	                    eventFacade.response = response;
	                } else if (error) {
	                    eventFacade.error = error;
	                }
	                if (tId) {
	                    eventFacade.transactionId = tId;
	                    this._clearTransaction(tId);
	                }
	                this.emit(type, eventFacade);
	                if (this.debug) {
	                    console.log("track result", eventFacade);
	                }
	            }.bind(this);

	            promise.then(function (response) {
	                dispatchEvent(response.every(function (item) {
	                    return item.status === "success";
	                }) ? "success" : "failure", response);
	            }).catch(function (error) {
	                dispatchEvent("failure", null, error);
	            });
	        }
	        /**
	         * Returns the default tracking data provided by a helper object.
	         *
	         * @method __getDefaultData
	         * @return {Object}
	         * @private
	         */

	    }, {
	        key: "_getDefaultData",
	        value: function _getDefaultData(state) {
	            return this.pageDefaults(state);
	        }
	        /**
	         * Returns a merged data between the host passed object and the default tracking data provided by a helper object.
	         *
	         * @method __mergeWith
	         * @return {Object}
	         * @private
	         */

	    }, {
	        key: "_mergeWith",
	        value: function _mergeWith(data, state) {
	            return Object.assign({}, this._getDefaultData(state), this.customParams, data);
	        }
	        /**
	         * Checks if this promise should be cancelled by rejecting it before it's sent to the facade.
	         *
	         * @method __addCancelHook
	         * @param {Promise} promise
	         * @returns {Promise}
	         * @private
	         */

	    }, {
	        key: "_addCancelHook",
	        value: function _addCancelHook(promise) {
	            var _this5 = this;

	            var tId = this.transaction.create();
	            return promise.then(function (data) {
	                return _this5.transaction.get(tId).shouldCancel ? Promise.reject(new Error("Page view cancelled")) : data;
	            });
	        }
	        /**
	         * Modify the data to include 'eventName' before it's sent to the facade.
	         *
	         * @method __addEventNameToPromise
	         * @param {String} eventName
	         * @param {Promise} promise
	         * @param {boolean} shouldMerge
	         * @returns {Promise}
	         * @private
	         */

	    }, {
	        key: "_addEventNameToPromise",
	        value: function _addEventNameToPromise(eventName, promise, shouldMerge) {
	            return promise.then(function (state, data) {
	                data = [shouldMerge ? this._mergeWith(data, state) : data];
	                data.unshift(eventName);
	                return data;
	            }.bind(this, this.routeState));
	        }
	        /**
	         * Run checks to the arguments passed to 'pageView' and 'track', set default page view eventName if it's not provided.
	         * Also merges the default data with the passed pageView data, and optionally for track data if a flag is set.
	         *
	         * @method __inspectArguments
	         * @param {String} type
	         * @param args
	         * @returns {Array}
	         * @private
	         */

	    }, {
	        key: "_inspectArguments",
	        value: function _inspectArguments(type) {
	            for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	                args[_key2 - 1] = arguments[_key2];
	            }

	            var shouldMerge = true;
	            if (type !== _ActionTypes2.default.PAGE_VIEW) {
	                // don't merge `pageDefaults` with track params unless it's explicitly requested by the third argument.
	                shouldMerge = false;
	                if (type === _ActionTypes2.default.TRACK) {
	                    (0, _invariant2.default)(typeof args[0] === "string", "Metrics 'track' method requires 'eventName' string as the first argument and object or promise as the second argument.");
	                }
	                // this might be confusing but for now, use the last argument as a flag for merge when it's boolean.
	                if (args.length >= 3 && typeof args[args.length - 1] === "boolean") {
	                    shouldMerge = args[args.length - 1];
	                }
	            }

	            // set default page view event name when missing.

	            var _args = args,
	                _args2 = _slicedToArray(_args, 2),
	                eventName = _args2[0],
	                params = _args2[1];

	            if (!params && typeof eventName !== "string") {
	                params = eventName;
	                eventName = type === _ActionTypes2.default.PAGE_VIEW ? this.pageViewEvent : null;
	            }

	            // make sure `params` is a promise.
	            if (!(0, _isPromise2.default)(params)) {
	                params = Promise.resolve(params);
	            }

	            // add cancel hook so that it can be cancelled(rejected) if the promise is still pending when the route changes.
	            if (type === _ActionTypes2.default.PAGE_VIEW) {
	                params = this._addCancelHook(params);
	            }

	            // PAGE_VIEW or TRACK should always have `eventName`.
	            if (eventName) {
	                params = this._addEventNameToPromise(eventName, params, shouldMerge);
	            }
	            args = [type, params];

	            if (type === _ActionTypes2.default.PAGE_VIEW) {
	                this._createTransaction(args);
	            }

	            return args;
	        }
	        /**
	         * @method _prepareTrack
	         * @param type
	         * @param args
	         * @private
	         */

	    }, {
	        key: "_prepareTrack",
	        value: function _prepareTrack(type) {
	            for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
	                args[_key3 - 1] = arguments[_key3];
	            }

	            if (!this.enabled) {
	                return;
	            }
	            args = this._inspectArguments.apply(this, [type].concat(_toConsumableArray(args)));
	            this._doTrack.apply(this, _toConsumableArray(args));
	        }
	        /**
	         * A click handler to perform custom link tracking, any element with 'metrics-*' attribute will be tracked.
	         *
	         * @method _handleClick
	         * @param {Object} params
	         * @private
	         */

	    }, {
	        key: "_handleClick",
	        value: function _handleClick() {
	            var _api;

	            (_api = this.api).track.apply(_api, arguments);
	        }
	    }, {
	        key: "_removeListeners",
	        value: function _removeListeners() {
	            this.removeAllListeners();
	        }
	    }, {
	        key: "_removeTrackBindingListener",
	        value: function _removeTrackBindingListener() {
	            if (this._trackBindingListener) {
	                this._trackBindingListener.remove();
	                this._trackBindingListener = null;
	            }
	        }
	    }, {
	        key: "api",
	        get: function get() {
	            return this.apiImpl;
	        }
	    }]);

	    return Metrics;
	}(_eventemitter2.default);

	function isMetrics(value) {
	    return value && typeof value.listen === "function" && typeof value.setRouteState === "function" && typeof value.useTrackBinding === "function" && typeof value.destroy === "function" && _typeof(value.api) === "object";
	}

	function createMetrics(options) {
	    var metrics = new Metrics(options);
	    return {
	        listen: metrics.listen.bind(metrics),
	        setRouteState: metrics.setRouteState.bind(metrics),
	        useTrackBinding: metrics.useTrackBinding.bind(metrics),
	        destroy: metrics.destroy.bind(metrics),
	        get enabled() {
	            return metrics.enabled;
	        },
	        get api() {
	            return metrics.api;
	        }
	    };
	}

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.TrackBindingPlugin = undefined;

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	exports.default = useTrackBindingPlugin;

	var _EventListener = __webpack_require__(29);

	var _EventListener2 = _interopRequireDefault(_EventListener);

	var _attr2obj = __webpack_require__(17);

	var _attr2obj2 = _interopRequireDefault(_attr2obj);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function isLeftClickEvent(event) {
	    return event.button === 0;
	}

	function isModifiedEvent(event) {
	    return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
	}

	var TrackBindingPlugin = exports.TrackBindingPlugin = function () {
	    function TrackBindingPlugin() {
	        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	            _ref$attributePrefix = _ref.attributePrefix,
	            attributePrefix = _ref$attributePrefix === undefined ? "data-metrics" : _ref$attributePrefix,
	            _ref$traverseParent = _ref.traverseParent,
	            traverseParent = _ref$traverseParent === undefined ? false : _ref$traverseParent;

	        _classCallCheck(this, TrackBindingPlugin);

	        this._attributePrefix = attributePrefix;
	        this._traverseParent = traverseParent;
	    }

	    _createClass(TrackBindingPlugin, [{
	        key: "listen",
	        value: function listen(callback) {
	            var rootElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document.body;

	            if (typeof callback !== "function") {
	                throw new Error("callback needs to be a function.");
	            }

	            if (rootElement && rootElement.nodeType !== 1) {
	                throw new Error("rootElement needs to be a valid node element.");
	            }

	            if (this._clickHandler) {
	                this.remove();
	            }

	            this._rootElement = rootElement;
	            this._clickHandler = _EventListener2.default.listen(rootElement, "click", this._handleClick.bind(this, callback));

	            return {
	                target: this,
	                remove: this.remove.bind(this)
	            };
	        }
	    }, {
	        key: "remove",
	        value: function remove() {
	            if (this._clickHandler) {
	                this._clickHandler.remove();
	                this._clickHandler = null;
	            }
	        }

	        /**
	         * A click handler to perform custom link tracking, any element with 'metrics-*' attribute will be tracked.
	         *
	         * @method _handleClick
	         * @param {Object} event
	         * @private
	         */

	    }, {
	        key: "_handleClick",
	        value: function _handleClick(callback, event) {
	            if (isModifiedEvent(event) || !isLeftClickEvent(event)) {
	                return;
	            }

	            var elem = event.target || event.srcElement;
	            var dataset = this._getData(elem);

	            if (this._traverseParent) {
	                var rootElement = this._rootElement;
	                while (elem !== rootElement) {
	                    elem = elem.parentElement || elem.parentNode;
	                    dataset = _extends({}, this._getData(elem), dataset);
	                }
	            }

	            if (!Object.keys(dataset).length) {
	                return;
	            }

	            var eventName = dataset && dataset.eventName;
	            var mergePagedefaults = dataset && dataset.mergePagedefaults;
	            delete dataset.mergePagedefaults;

	            if (eventName) {
	                delete dataset.eventName;
	                callback(eventName, dataset, mergePagedefaults === "true");
	            }
	        }
	    }, {
	        key: "_getData",
	        value: function _getData(elem) {
	            return (0, _attr2obj2.default)(elem, this._attributePrefix);
	        }
	    }]);

	    return TrackBindingPlugin;
	}();

	function useTrackBindingPlugin(_ref2) {
	    var callback = _ref2.callback,
	        rootElement = _ref2.rootElement,
	        attributePrefix = _ref2.attributePrefix,
	        traverseParent = _ref2.traverseParent;

	    var trackBindingPlugin = new TrackBindingPlugin({
	        attributePrefix: attributePrefix,
	        traverseParent: traverseParent
	    });
	    return trackBindingPlugin.listen(callback, rootElement);
	}

/***/ }),
/* 11 */
/***/ (function(module, exports) {

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	exports.filterKeysByType = filterKeysByType;
	exports.aggregateApisByType = aggregateApisByType;
	exports.default = extractApis;

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	var EXCLUDES = ["constructor"].concat(Object.getOwnPropertyNames(Object.getPrototypeOf({})));

	function filterKeysByType(obj) {
	    var total = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
	    var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "function";

	    return Object.getOwnPropertyNames(obj).filter(function (key) {
	        return total.indexOf(key) === -1 && EXCLUDES.indexOf(key) === -1 && key.indexOf("_") !== 0 && // consider it's private
	        obj.hasOwnProperty(key) && _typeof(obj[key]) === type;
	    });
	}

	function aggregateApisByType(obj) {
	    var total = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

	    var keys = [];
	    while (obj !== null) {
	        // eslint-disable-line no-eq-null
	        var arr = filterKeysByType(obj, total);
	        keys.push.apply(keys, _toConsumableArray(arr));
	        obj = Object.getPrototypeOf(obj);
	    }
	    return keys;
	}

	// extracts lists of methods from each service object.
	function extractApis(services) {
	    services = Array.isArray(services) ? services : [services];
	    var apis = services.reduce(function (total, service) {
	        var obj = service.constructor === Object ? service : Object.getPrototypeOf(service);
	        var keys = aggregateApisByType(obj, total);
	        total.push.apply(total, _toConsumableArray(keys));
	        return total;
	    }, []);

	    return apis;
	}

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	exports.getMountedInstances = getMountedInstances;
	exports.clearMountedInstances = clearMountedInstances;
	exports.default = useMetrics;

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _ExecutionEnvironment = __webpack_require__(4);

	var _hoistNonReactStatics = __webpack_require__(13);

	var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

	var _PropTypes = __webpack_require__(2);

	var _PropTypes2 = _interopRequireDefault(_PropTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var mountedInstances = [];

	function getMountedInstances() {
	    return mountedInstances;
	}

	// convenient method for unit test
	function clearMountedInstances() {
	    mountedInstances.length = 0;
	}

	function getDisplayName(Comp) {
	    return Comp.displayName || Comp.name || "Component";
	}

	function wrap(ComposedComponent) {
	    var _class, _temp;

	    var Metrics = (_temp = _class = function (_Component) {
	        _inherits(Metrics, _Component);

	        function Metrics() {
	            _classCallCheck(this, Metrics);

	            return _possibleConstructorReturn(this, (Metrics.__proto__ || Object.getPrototypeOf(Metrics)).apply(this, arguments));
	        }

	        _createClass(Metrics, [{
	            key: "componentWillMount",
	            value: function componentWillMount() {
	                if (!_ExecutionEnvironment.canUseDOM) {
	                    return;
	                }

	                mountedInstances.push(Metrics);
	            }

	            // context unit test fails w/o this, why??

	        }, {
	            key: "componentWillUnmount",
	            value: function componentWillUnmount() {
	                var index = mountedInstances.indexOf(this);
	                mountedInstances.splice(index, 1);
	            }
	        }, {
	            key: "render",
	            value: function render() {
	                return _react2.default.createElement(ComposedComponent, _extends({}, this.props, this.context));
	            }
	        }]);

	        return Metrics;
	    }(_react.Component), _class.displayName = "Metrics(" + getDisplayName(ComposedComponent) + ")", _class.contextTypes = {
	        metrics: _PropTypes2.default.metrics
	    }, _temp);

	    return (0, _hoistNonReactStatics2.default)(Metrics, ComposedComponent);
	}

	function useMetrics() {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	    }

	    if (typeof args[0] === "function") {
	        return wrap.apply(undefined, args);
	    }

	    return function (target) {
	        return wrap.apply(undefined, [target].concat(args));
	    };
	}

/***/ }),
/* 13 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2015, Yahoo! Inc.
	 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
	 */
	'use strict';

	var REACT_STATICS = {
	    childContextTypes: true,
	    contextTypes: true,
	    defaultProps: true,
	    displayName: true,
	    getDefaultProps: true,
	    mixins: true,
	    propTypes: true,
	    type: true
	};

	var KNOWN_STATICS = {
	    name: true,
	    length: true,
	    prototype: true,
	    caller: true,
	    arguments: true,
	    arity: true
	};

	var isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';

	module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {
	    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components
	        var keys = Object.getOwnPropertyNames(sourceComponent);

	        /* istanbul ignore else */
	        if (isGetOwnPropertySymbolsAvailable) {
	            keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));
	        }

	        for (var i = 0; i < keys.length; ++i) {
	            if (!REACT_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {
	                try {
	                    targetComponent[keys[i]] = sourceComponent[keys[i]];
	                } catch (error) {

	                }
	            }
	        }
	    }

	    return targetComponent;
	};


/***/ }),
/* 14 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */

	'use strict';

	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

	module.exports = ReactPropTypesSecret;


/***/ }),
/* 15 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_15__;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.defaultService = undefined;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _defaultService;

	exports.default = createService;

	var _ActionTypes = __webpack_require__(8);

	var _ActionTypes2 = _interopRequireDefault(_ActionTypes);

	var _extractApis = __webpack_require__(11);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; } /* eslint-disable no-empty */


	var noop = function noop() {};

	function isService(obj) {
	    var functionProps = (0, _extractApis.aggregateApisByType)(obj);
	    return functionProps.length > 0;
	}

	var defaultService = exports.defaultService = (_defaultService = {}, _defineProperty(_defaultService, _ActionTypes2.default.PAGE_VIEW, noop), _defineProperty(_defaultService, _ActionTypes2.default.TRACK, noop), _defaultService);

	function createService() {
	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var api = options.api;

	    var instance = defaultService;
	    function instantiate() {
	        var ClassType = api;
	        return new ClassType(options);
	    }
	    if (typeof api === "function") {
	        var inst = void 0;
	        try {
	            inst = api(options);
	        } catch (err) {} finally {
	            if (!inst || !isService(inst)) {
	                inst = instantiate();
	            }
	            if (isService(inst)) {
	                instance = inst;
	            }
	        }
	    } else if (api && (typeof api === "undefined" ? "undefined" : _typeof(api)) === "object" && isService(api)) {
	        instance = api;
	    }
	    var name = options.name || instance.name;
	    return { name: name, apis: instance };
	}

/***/ }),
/* 17 */
/***/ (function(module, exports) {

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	var attr2obj = function attr2obj(elem) {
	    var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "data";

	    var attrs = elem.attributes;
	    var dataAttrs = {};
	    var rdashAlpha = /-([\da-z])/gi;
	    var fcamelCase = function fcamelCase(all, letter) {
	        return letter.toUpperCase();
	    };
	    var camelCase = function camelCase(string) {
	        return string.replace(rdashAlpha, fcamelCase);
	    };

	    if (elem.nodeType === 1) {
	        var i = attrs.length;
	        while (i--) {
	            var name = attrs[i].name;
	            if (name.indexOf(prefix + "-") === 0) {
	                var camelName = camelCase(name.slice(prefix.length + 1));
	                dataAttrs[camelName] = elem.getAttribute(name);
	            }
	        }
	    }
	    return dataAttrs;
	};

	exports.default = attr2obj;

/***/ }),
/* 18 */
/***/ (function(module, exports) {

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = isPromise;
	// to support Promise-like object.
	function isPromise(value) {
	    return value && typeof value.then === "function";
	}

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _class, _temp;

	var _react = __webpack_require__(7);

	var _propTypes = __webpack_require__(6);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _reactDom = __webpack_require__(15);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _invariant = __webpack_require__(1);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _warning = __webpack_require__(3);

	var _warning2 = _interopRequireDefault(_warning);

	var _PropTypes = __webpack_require__(2);

	var _PropTypes2 = _interopRequireDefault(_PropTypes);

	var _useTrackBindingPlugin = __webpack_require__(10);

	var _useTrackBindingPlugin2 = _interopRequireDefault(_useTrackBindingPlugin);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var MetricsElement = (_temp = _class = function (_Component) {
	    _inherits(MetricsElement, _Component);

	    function MetricsElement() {
	        _classCallCheck(this, MetricsElement);

	        return _possibleConstructorReturn(this, (MetricsElement.__proto__ || Object.getPrototypeOf(MetricsElement)).apply(this, arguments));
	    }

	    _createClass(MetricsElement, [{
	        key: "componentDidMount",
	        value: function componentDidMount() {
	            var _context = this.context,
	                metrics = _context.metrics,
	                _metricsConfig = _context._metricsConfig;


	            (0, _invariant2.default)(metrics, "MetricsElement requires metrics HOC to exist in the parent tree.");

	            var useTrackBinding = _metricsConfig.useTrackBinding,
	                attributePrefix = _metricsConfig.attributePrefix,
	                suppressTrackBindingWarning = _metricsConfig.suppressTrackBindingWarning;


	            if (!suppressTrackBindingWarning) {
	                (0, _warning2.default)(!useTrackBinding, "You are using 'MetricsElement' while default track binding is turned on. " + "It is recommended that you stick with either one to avoid double tracking accidentally. " + "If you intentionally use both and want to suppress this warning, pass 'suppressTrackBindingWarning=true' to the metrics options.");
	            }

	            this._trackBindingListener = (0, _useTrackBindingPlugin2.default)({
	                callback: this._handleClick.bind(this),
	                rootElement: _reactDom2.default.findDOMNode(this),
	                attributePrefix: attributePrefix,
	                traverseParent: true
	            });
	        }
	    }, {
	        key: "componentWillUnmount",
	        value: function componentWillUnmount() {
	            if (this._trackBindingListener) {
	                this._trackBindingListener.remove();
	                this._trackBindingListener = null;
	            }
	        }
	    }, {
	        key: "_handleClick",
	        value: function _handleClick() {
	            var _context$metrics;

	            (_context$metrics = this.context.metrics).track.apply(_context$metrics, arguments);
	        }
	    }, {
	        key: "render",
	        value: function render() {
	            var _props = this.props,
	                element = _props.element,
	                children = _props.children,
	                rest = _objectWithoutProperties(_props, ["element", "children"]);

	            if (!element) {
	                return _react.Children.only(children);
	            }

	            return (0, _react.isValidElement)(element) ? (0, _react.cloneElement)(element, rest) : (0, _react.createElement)(element, rest, children);
	        }
	    }]);

	    return MetricsElement;
	}(_react.Component), _class.contextTypes = {
	    metrics: _PropTypes2.default.metrics,
	    _metrics: _propTypes2.default.object,
	    _metricsConfig: _propTypes2.default.object
	}, _class.propTypes = {
	    children: _propTypes2.default.node,
	    element: _propTypes2.default.any
	}, _temp);
	exports.default = MetricsElement;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = findRouteComponent;

	var _exposeMetrics = __webpack_require__(12);

	function findRouteComponent() {
	    var routes = (0, _exposeMetrics.getMountedInstances)();
	    var component = routes && routes.length > 0 && routes[routes.length - 1];
	    return component;
	}

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = getRouteState;

	var _locationEquals = __webpack_require__(23);

	var _locationEquals2 = _interopRequireDefault(_locationEquals);

	var _isLocationValid = __webpack_require__(22);

	var _isLocationValid2 = _interopRequireDefault(_isLocationValid);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function mergeParam(location, params) {
	    return Object.keys(location).reduce(function (obj, key) {
	        obj[key] = location[key];
	        return obj;
	    }, { params: params });
	}

	function getRouteState(newProps) {
	    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    if ((0, _isLocationValid2.default)(newProps.location) && !(0, _locationEquals2.default)(props.location, newProps.location)) {
	        // additional params for the dynamic segments of the URL if available.
	        var location = newProps.location,
	            params = newProps.params;

	        if (location.params || !params) {
	            return location;
	        }
	        var routeState = mergeParam(location, params);
	        return routeState;
	    }
	    return null;
	}

/***/ }),
/* 22 */
/***/ (function(module, exports) {

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	exports.default = isLocationValid;
	/**
	 * `location` is a plain object which represents the current location in browser similar to document.location.
	 * see https://github.com/rackt/history/blob/master/docs/Location.md
	 *
	 * @method isLocationValid
	 * @param location
	 * @returns {boolean}
	 */
	function isLocationValid(location) {
	    return !!location && (typeof location === "undefined" ? "undefined" : _typeof(location)) === "object" && location.hasOwnProperty("pathname") && location.hasOwnProperty("hash") && location.hasOwnProperty("search") && location.hasOwnProperty("state");
	}

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = locationEquals;

	var _deepEqual = __webpack_require__(25);

	var _deepEqual2 = _interopRequireDefault(_deepEqual);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function locationEquals(a, b) {
	    if (!a && !b) {
	        return true;
	    }
	    if (a && !b || !a && b) {
	        return false;
	    }

	    return a.pathname === b.pathname && a.search === b.search && (0, _deepEqual2.default)(a.state, b.state);
	}

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	exports.default = metrics;

	var _react = __webpack_require__(7);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(6);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _reactDom = __webpack_require__(15);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _invariant = __webpack_require__(1);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _ExecutionEnvironment = __webpack_require__(4);

	var _PropTypes = __webpack_require__(2);

	var _createMetrics = __webpack_require__(9);

	var _createMetrics2 = _interopRequireDefault(_createMetrics);

	var _getRouteState = __webpack_require__(21);

	var _getRouteState2 = _interopRequireDefault(_getRouteState);

	var _findRouteComponent = __webpack_require__(20);

	var _findRouteComponent2 = _interopRequireDefault(_findRouteComponent);

	var _hoistNonReactStatics = __webpack_require__(13);

	var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function getDisplayName(Comp) {
	    return Comp.displayName || Comp.name || "Component";
	}

	var mountedInstances = void 0;

	function metrics(metricsOrConfig) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    var autoTrackPageView = options.autoTrackPageView !== false;
	    var useTrackBinding = options.useTrackBinding !== false;
	    var attributePrefix = options.attributePrefix;
	    var suppressTrackBindingWarning = !!options.suppressTrackBindingWarning;
	    var getNewRouteState = options.getRouteState || _getRouteState2.default;
	    var findNewRouteComponent = options.findRouteComponent || _findRouteComponent2.default;
	    var metricsInstance = (0, _createMetrics.isMetrics)(metricsOrConfig) ? metricsOrConfig : (0, _createMetrics2.default)(metricsOrConfig);

	    return function wrap(ComposedComponent) {
	        var _class, _temp;

	        var MetricsContainer = (_temp = _class = function (_Component) {
	            _inherits(MetricsContainer, _Component);

	            function MetricsContainer() {
	                _classCallCheck(this, MetricsContainer);

	                return _possibleConstructorReturn(this, (MetricsContainer.__proto__ || Object.getPrototypeOf(MetricsContainer)).apply(this, arguments));
	            }

	            _createClass(MetricsContainer, [{
	                key: "componentWillMount",
	                value: function componentWillMount() {
	                    if (!_ExecutionEnvironment.canUseDOM) {
	                        return;
	                    }

	                    var instances = this.constructor.getMountedMetricsInstances();
	                    // Ensure this component should only be added in one root location.
	                    if (instances.length === 1) {
	                        (0, _invariant2.default)(false, "`metrics` should only be added once to the root level component. You have added to both %s and %s.", getDisplayName(instances[0]), getDisplayName(ComposedComponent));
	                    }
	                    instances.push(ComposedComponent);

	                    this._newRouteState = getNewRouteState(this.props);
	                    if (this._newRouteState) {
	                        this._getMetrics().setRouteState(this._newRouteState);
	                    }
	                }
	            }, {
	                key: "componentDidMount",
	                value: function componentDidMount() {
	                    if (useTrackBinding) {
	                        var rootElement = _reactDom2.default.findDOMNode(this);
	                        // TODO: is this invariant check still valid after react >= 0.14.0?
	                        (0, _invariant2.default)(rootElement, "`metrics` should be added to the root most component which renders node element for declarative tracking to work.");
	                        this._getMetrics().useTrackBinding(rootElement, attributePrefix);
	                    }

	                    if (this._newRouteState) {
	                        this._handleRouteStateChange(this._newRouteState);
	                        this._newRouteState = null;
	                    }
	                }
	            }, {
	                key: "componentWillReceiveProps",
	                value: function componentWillReceiveProps(newProps) {
	                    this._newRouteState = getNewRouteState(newProps, this.props);
	                    if (this._newRouteState) {
	                        this._getMetrics().setRouteState(this._newRouteState);
	                    }
	                }
	            }, {
	                key: "componentDidUpdate",
	                value: function componentDidUpdate() {
	                    if (this._newRouteState) {
	                        this._handleRouteStateChange(this._newRouteState);
	                        this._newRouteState = null;
	                    }
	                }
	            }, {
	                key: "componentWillUnmount",
	                value: function componentWillUnmount() {
	                    var instances = this.constructor.getMountedMetricsInstances();
	                    var index = instances.indexOf(ComposedComponent);
	                    instances.splice(index, 1);

	                    this._getMetrics().destroy();
	                }
	            }, {
	                key: "getChildContext",
	                value: function getChildContext() {
	                    return {
	                        metrics: this._getMetrics().api,
	                        _metricsConfig: {
	                            autoTrackPageView: autoTrackPageView,
	                            useTrackBinding: useTrackBinding,
	                            attributePrefix: attributePrefix,
	                            suppressTrackBindingWarning: suppressTrackBindingWarning,
	                            getNewRouteState: getNewRouteState,
	                            findNewRouteComponent: findNewRouteComponent
	                        }
	                    };
	                }
	            }, {
	                key: "_getMetrics",
	                value: function _getMetrics() {
	                    return metricsInstance;
	                }
	                /**
	                 * Triggered when the route changes and fires page view tracking.
	                 *
	                 * @method _handleRouteStateChange
	                 * @param {Object} props
	                 * @private
	                 */

	            }, {
	                key: "_handleRouteStateChange",
	                value: function _handleRouteStateChange(routeState) {
	                    var component = findNewRouteComponent();
	                    var metricsInst = this._getMetrics();
	                    var pageViewParams = void 0;
	                    var shouldSuppress = false;

	                    if (component) {
	                        var ret = component.willTrackPageView && component.willTrackPageView(routeState);
	                        if (ret === false) {
	                            shouldSuppress = true;
	                        } else if (ret) {
	                            pageViewParams = ret;
	                        }
	                    }

	                    if (metricsInst.enabled && autoTrackPageView && !shouldSuppress) {
	                        (0, _invariant2.default)(typeof metricsInst.api.pageView === "function", "react-metrics: 'pageView' api needs to be defined for automatic page view tracking.");
	                        metricsInst.api.pageView(pageViewParams);
	                    }
	                }
	                /**
	                 * Renders composed component.
	                 *
	                 * @method render
	                 * @returns {ReactElement}
	                 */

	            }, {
	                key: "render",
	                value: function render() {
	                    return _react2.default.createElement(ComposedComponent, _extends({}, this.props, this.getChildContext()));
	                }
	            }], [{
	                key: "getMountedMetricsInstances",
	                value: function getMountedMetricsInstances() {
	                    // eslint-disable-line react/sort-comp
	                    if (!mountedInstances) {
	                        mountedInstances = [];
	                    }
	                    return mountedInstances;
	                }
	            }]);

	            return MetricsContainer;
	        }(_react.Component), _class.displayName = "MetricsContainer", _class.childContextTypes = {
	            metrics: _PropTypes.metrics.isRequired,
	            _metricsConfig: _propTypes2.default.object
	        }, _class.propTypes = {
	            location: _PropTypes.location,
	            params: _propTypes2.default.object
	        }, _temp);


	        return (0, _hoistNonReactStatics2.default)(MetricsContainer, ComposedComponent);
	    };
	}

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	var pSlice = Array.prototype.slice;
	var objectKeys = __webpack_require__(27);
	var isArguments = __webpack_require__(26);

	var deepEqual = module.exports = function (actual, expected, opts) {
	  if (!opts) opts = {};
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;

	  } else if (actual instanceof Date && expected instanceof Date) {
	    return actual.getTime() === expected.getTime();

	  // 7.3. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
	    return opts.strict ? actual === expected : actual == expected;

	  // 7.4. For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else {
	    return objEquiv(actual, expected, opts);
	  }
	}

	function isUndefinedOrNull(value) {
	  return value === null || value === undefined;
	}

	function isBuffer (x) {
	  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
	  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
	    return false;
	  }
	  if (x.length > 0 && typeof x[0] !== 'number') return false;
	  return true;
	}

	function objEquiv(a, b, opts) {
	  var i, key;
	  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
	    return false;
	  // an identical 'prototype' property.
	  if (a.prototype !== b.prototype) return false;
	  //~~~I've managed to break Object.keys through screwy arguments passing.
	  //   Converting to array solves the problem.
	  if (isArguments(a)) {
	    if (!isArguments(b)) {
	      return false;
	    }
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return deepEqual(a, b, opts);
	  }
	  if (isBuffer(a)) {
	    if (!isBuffer(b)) {
	      return false;
	    }
	    if (a.length !== b.length) return false;
	    for (i = 0; i < a.length; i++) {
	      if (a[i] !== b[i]) return false;
	    }
	    return true;
	  }
	  try {
	    var ka = objectKeys(a),
	        kb = objectKeys(b);
	  } catch (e) {//happens when one is a string literal and the other isn't
	    return false;
	  }
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length != kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] != kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!deepEqual(a[key], b[key], opts)) return false;
	  }
	  return typeof a === typeof b;
	}


/***/ }),
/* 26 */
/***/ (function(module, exports) {

	var supportsArgumentsClass = (function(){
	  return Object.prototype.toString.call(arguments)
	})() == '[object Arguments]';

	exports = module.exports = supportsArgumentsClass ? supported : unsupported;

	exports.supported = supported;
	function supported(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	};

	exports.unsupported = unsupported;
	function unsupported(object){
	  return object &&
	    typeof object == 'object' &&
	    typeof object.length == 'number' &&
	    Object.prototype.hasOwnProperty.call(object, 'callee') &&
	    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
	    false;
	};


/***/ }),
/* 27 */
/***/ (function(module, exports) {

	exports = module.exports = typeof Object.keys === 'function'
	  ? Object.keys : shim;

	exports.shim = shim;
	function shim (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var has = Object.prototype.hasOwnProperty;

	//
	// We store our EE objects in a plain object whose properties are event names.
	// If `Object.create(null)` is not supported we prefix the event names with a
	// `~` to make sure that the built-in object properties are not overridden or
	// used as an attack vector.
	// We also assume that `Object.create(null)` is available when the event name
	// is an ES6 Symbol.
	//
	var prefix = typeof Object.create !== 'function' ? '~' : false;

	/**
	 * Representation of a single EventEmitter function.
	 *
	 * @param {Function} fn Event handler to be called.
	 * @param {Mixed} context Context for function execution.
	 * @param {Boolean} [once=false] Only emit once
	 * @api private
	 */
	function EE(fn, context, once) {
	  this.fn = fn;
	  this.context = context;
	  this.once = once || false;
	}

	/**
	 * Minimal EventEmitter interface that is molded against the Node.js
	 * EventEmitter interface.
	 *
	 * @constructor
	 * @api public
	 */
	function EventEmitter() { /* Nothing to set */ }

	/**
	 * Hold the assigned EventEmitters by name.
	 *
	 * @type {Object}
	 * @private
	 */
	EventEmitter.prototype._events = undefined;

	/**
	 * Return an array listing the events for which the emitter has registered
	 * listeners.
	 *
	 * @returns {Array}
	 * @api public
	 */
	EventEmitter.prototype.eventNames = function eventNames() {
	  var events = this._events
	    , names = []
	    , name;

	  if (!events) return names;

	  for (name in events) {
	    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
	  }

	  if (Object.getOwnPropertySymbols) {
	    return names.concat(Object.getOwnPropertySymbols(events));
	  }

	  return names;
	};

	/**
	 * Return a list of assigned event listeners.
	 *
	 * @param {String} event The events that should be listed.
	 * @param {Boolean} exists We only need to know if there are listeners.
	 * @returns {Array|Boolean}
	 * @api public
	 */
	EventEmitter.prototype.listeners = function listeners(event, exists) {
	  var evt = prefix ? prefix + event : event
	    , available = this._events && this._events[evt];

	  if (exists) return !!available;
	  if (!available) return [];
	  if (available.fn) return [available.fn];

	  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {
	    ee[i] = available[i].fn;
	  }

	  return ee;
	};

	/**
	 * Emit an event to all registered event listeners.
	 *
	 * @param {String} event The name of the event.
	 * @returns {Boolean} Indication if we've emitted an event.
	 * @api public
	 */
	EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
	  var evt = prefix ? prefix + event : event;

	  if (!this._events || !this._events[evt]) return false;

	  var listeners = this._events[evt]
	    , len = arguments.length
	    , args
	    , i;

	  if ('function' === typeof listeners.fn) {
	    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

	    switch (len) {
	      case 1: return listeners.fn.call(listeners.context), true;
	      case 2: return listeners.fn.call(listeners.context, a1), true;
	      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
	      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
	      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
	      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
	    }

	    for (i = 1, args = new Array(len -1); i < len; i++) {
	      args[i - 1] = arguments[i];
	    }

	    listeners.fn.apply(listeners.context, args);
	  } else {
	    var length = listeners.length
	      , j;

	    for (i = 0; i < length; i++) {
	      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

	      switch (len) {
	        case 1: listeners[i].fn.call(listeners[i].context); break;
	        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
	        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
	        default:
	          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
	            args[j - 1] = arguments[j];
	          }

	          listeners[i].fn.apply(listeners[i].context, args);
	      }
	    }
	  }

	  return true;
	};

	/**
	 * Register a new EventListener for the given event.
	 *
	 * @param {String} event Name of the event.
	 * @param {Function} fn Callback function.
	 * @param {Mixed} [context=this] The context of the function.
	 * @api public
	 */
	EventEmitter.prototype.on = function on(event, fn, context) {
	  var listener = new EE(fn, context || this)
	    , evt = prefix ? prefix + event : event;

	  if (!this._events) this._events = prefix ? {} : Object.create(null);
	  if (!this._events[evt]) this._events[evt] = listener;
	  else {
	    if (!this._events[evt].fn) this._events[evt].push(listener);
	    else this._events[evt] = [
	      this._events[evt], listener
	    ];
	  }

	  return this;
	};

	/**
	 * Add an EventListener that's only called once.
	 *
	 * @param {String} event Name of the event.
	 * @param {Function} fn Callback function.
	 * @param {Mixed} [context=this] The context of the function.
	 * @api public
	 */
	EventEmitter.prototype.once = function once(event, fn, context) {
	  var listener = new EE(fn, context || this, true)
	    , evt = prefix ? prefix + event : event;

	  if (!this._events) this._events = prefix ? {} : Object.create(null);
	  if (!this._events[evt]) this._events[evt] = listener;
	  else {
	    if (!this._events[evt].fn) this._events[evt].push(listener);
	    else this._events[evt] = [
	      this._events[evt], listener
	    ];
	  }

	  return this;
	};

	/**
	 * Remove event listeners.
	 *
	 * @param {String} event The event we want to remove.
	 * @param {Function} fn The listener that we need to find.
	 * @param {Mixed} context Only remove listeners matching this context.
	 * @param {Boolean} once Only remove once listeners.
	 * @api public
	 */
	EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
	  var evt = prefix ? prefix + event : event;

	  if (!this._events || !this._events[evt]) return this;

	  var listeners = this._events[evt]
	    , events = [];

	  if (fn) {
	    if (listeners.fn) {
	      if (
	           listeners.fn !== fn
	        || (once && !listeners.once)
	        || (context && listeners.context !== context)
	      ) {
	        events.push(listeners);
	      }
	    } else {
	      for (var i = 0, length = listeners.length; i < length; i++) {
	        if (
	             listeners[i].fn !== fn
	          || (once && !listeners[i].once)
	          || (context && listeners[i].context !== context)
	        ) {
	          events.push(listeners[i]);
	        }
	      }
	    }
	  }

	  //
	  // Reset the array, or remove it completely if we have no more listeners.
	  //
	  if (events.length) {
	    this._events[evt] = events.length === 1 ? events[0] : events;
	  } else {
	    delete this._events[evt];
	  }

	  return this;
	};

	/**
	 * Remove all listeners or only the listeners for the specified event.
	 *
	 * @param {String} event The event want to remove all listeners for.
	 * @api public
	 */
	EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
	  if (!this._events) return this;

	  if (event) delete this._events[prefix ? prefix + event : event];
	  else this._events = prefix ? {} : Object.create(null);

	  return this;
	};

	//
	// Alias methods names because people roll like that.
	//
	EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
	EventEmitter.prototype.addListener = EventEmitter.prototype.on;

	//
	// This function doesn't apply anymore.
	//
	EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
	  return this;
	};

	//
	// Expose the prefix.
	//
	EventEmitter.prefixed = prefix;

	//
	// Expose the module.
	//
	if (true) {
	  module.exports = EventEmitter;
	}


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 * @typechecks
	 */

	var emptyFunction = __webpack_require__(5);

	/**
	 * Upstream version of event listener. Does not take into account specific
	 * nature of platform.
	 */
	var EventListener = {
	  /**
	   * Listen to DOM events during the bubble phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  listen: function listen(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, false);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, false);
	        }
	      };
	    } else if (target.attachEvent) {
	      target.attachEvent('on' + eventType, callback);
	      return {
	        remove: function remove() {
	          target.detachEvent('on' + eventType, callback);
	        }
	      };
	    }
	  },

	  /**
	   * Listen to DOM events during the capture phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  capture: function capture(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, true);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, true);
	        }
	      };
	    } else {
	      if (true) {
	        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
	      }
	      return {
	        remove: emptyFunction
	      };
	    }
	  },

	  registerDefault: function registerDefault() {}
	};

	module.exports = EventListener;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */

	'use strict';

	if (true) {
	  var invariant = __webpack_require__(1);
	  var warning = __webpack_require__(3);
	  var ReactPropTypesSecret = __webpack_require__(14);
	  var loggedTypeFailures = {};
	}

	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?Function} getStack Returns the component stack.
	 * @private
	 */
	function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
	  if (true) {
	    for (var typeSpecName in typeSpecs) {
	      if (typeSpecs.hasOwnProperty(typeSpecName)) {
	        var error;
	        // Prop type validation may throw. In case they do, we don't want to
	        // fail the render phase where it didn't fail before. So we log it.
	        // After these have been cleaned up, we'll let them throw.
	        try {
	          // This is intentionally an invariant that gets caught. It's the same
	          // behavior as without this statement except with a better message.
	          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', location, typeSpecName);
	          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	        } catch (ex) {
	          error = ex;
	        }
	        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);
	        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	          // Only monitor this failure once because there tends to be a lot of the
	          // same error.
	          loggedTypeFailures[error.message] = true;

	          var stack = getStack ? getStack() : '';

	          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
	        }
	      }
	    }
	  }
	}

	module.exports = checkPropTypes;


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */

	'use strict';

	var emptyFunction = __webpack_require__(5);
	var invariant = __webpack_require__(1);
	var warning = __webpack_require__(3);

	var ReactPropTypesSecret = __webpack_require__(14);
	var checkPropTypes = __webpack_require__(30);

	module.exports = function(isValidElement, throwOnDirectAccess) {
	  /* global Symbol */
	  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

	  /**
	   * Returns the iterator method function contained on the iterable object.
	   *
	   * Be sure to invoke the function with the iterable as context:
	   *
	   *     var iteratorFn = getIteratorFn(myIterable);
	   *     if (iteratorFn) {
	   *       var iterator = iteratorFn.call(myIterable);
	   *       ...
	   *     }
	   *
	   * @param {?object} maybeIterable
	   * @return {?function}
	   */
	  function getIteratorFn(maybeIterable) {
	    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }

	  /**
	   * Collection of methods that allow declaration and validation of props that are
	   * supplied to React components. Example usage:
	   *
	   *   var Props = require('ReactPropTypes');
	   *   var MyArticle = React.createClass({
	   *     propTypes: {
	   *       // An optional string prop named "description".
	   *       description: Props.string,
	   *
	   *       // A required enum prop named "category".
	   *       category: Props.oneOf(['News','Photos']).isRequired,
	   *
	   *       // A prop named "dialog" that requires an instance of Dialog.
	   *       dialog: Props.instanceOf(Dialog).isRequired
	   *     },
	   *     render: function() { ... }
	   *   });
	   *
	   * A more formal specification of how these methods are used:
	   *
	   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	   *   decl := ReactPropTypes.{type}(.isRequired)?
	   *
	   * Each and every declaration produces a function with the same signature. This
	   * allows the creation of custom validation functions. For example:
	   *
	   *  var MyLink = React.createClass({
	   *    propTypes: {
	   *      // An optional string or URI prop named "href".
	   *      href: function(props, propName, componentName) {
	   *        var propValue = props[propName];
	   *        if (propValue != null && typeof propValue !== 'string' &&
	   *            !(propValue instanceof URI)) {
	   *          return new Error(
	   *            'Expected a string or an URI for ' + propName + ' in ' +
	   *            componentName
	   *          );
	   *        }
	   *      }
	   *    },
	   *    render: function() {...}
	   *  });
	   *
	   * @internal
	   */

	  var ANONYMOUS = '<<anonymous>>';

	  // Important!
	  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
	  var ReactPropTypes = {
	    array: createPrimitiveTypeChecker('array'),
	    bool: createPrimitiveTypeChecker('boolean'),
	    func: createPrimitiveTypeChecker('function'),
	    number: createPrimitiveTypeChecker('number'),
	    object: createPrimitiveTypeChecker('object'),
	    string: createPrimitiveTypeChecker('string'),
	    symbol: createPrimitiveTypeChecker('symbol'),

	    any: createAnyTypeChecker(),
	    arrayOf: createArrayOfTypeChecker,
	    element: createElementTypeChecker(),
	    instanceOf: createInstanceTypeChecker,
	    node: createNodeChecker(),
	    objectOf: createObjectOfTypeChecker,
	    oneOf: createEnumTypeChecker,
	    oneOfType: createUnionTypeChecker,
	    shape: createShapeTypeChecker
	  };

	  /**
	   * inlined Object.is polyfill to avoid requiring consumers ship their own
	   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	   */
	  /*eslint-disable no-self-compare*/
	  function is(x, y) {
	    // SameValue algorithm
	    if (x === y) {
	      // Steps 1-5, 7-10
	      // Steps 6.b-6.e: +0 != -0
	      return x !== 0 || 1 / x === 1 / y;
	    } else {
	      // Step 6.a: NaN == NaN
	      return x !== x && y !== y;
	    }
	  }
	  /*eslint-enable no-self-compare*/

	  /**
	   * We use an Error-like object for backward compatibility as people may call
	   * PropTypes directly and inspect their output. However, we don't use real
	   * Errors anymore. We don't inspect their stack anyway, and creating them
	   * is prohibitively expensive if they are created too often, such as what
	   * happens in oneOfType() for any type before the one that matched.
	   */
	  function PropTypeError(message) {
	    this.message = message;
	    this.stack = '';
	  }
	  // Make `instanceof Error` still work for returned errors.
	  PropTypeError.prototype = Error.prototype;

	  function createChainableTypeChecker(validate) {
	    if (true) {
	      var manualPropTypeCallCache = {};
	      var manualPropTypeWarningCount = 0;
	    }
	    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
	      componentName = componentName || ANONYMOUS;
	      propFullName = propFullName || propName;

	      if (secret !== ReactPropTypesSecret) {
	        if (throwOnDirectAccess) {
	          // New behavior only for users of `prop-types` package
	          invariant(
	            false,
	            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
	            'Use `PropTypes.checkPropTypes()` to call them. ' +
	            'Read more at http://fb.me/use-check-prop-types'
	          );
	        } else if (("development") !== 'production' && typeof console !== 'undefined') {
	          // Old behavior for people using React.PropTypes
	          var cacheKey = componentName + ':' + propName;
	          if (
	            !manualPropTypeCallCache[cacheKey] &&
	            // Avoid spamming the console because they are often not actionable except for lib authors
	            manualPropTypeWarningCount < 3
	          ) {
	            warning(
	              false,
	              'You are manually calling a React.PropTypes validation ' +
	              'function for the `%s` prop on `%s`. This is deprecated ' +
	              'and will throw in the standalone `prop-types` package. ' +
	              'You may be seeing this warning due to a third-party PropTypes ' +
	              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',
	              propFullName,
	              componentName
	            );
	            manualPropTypeCallCache[cacheKey] = true;
	            manualPropTypeWarningCount++;
	          }
	        }
	      }
	      if (props[propName] == null) {
	        if (isRequired) {
	          if (props[propName] === null) {
	            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
	          }
	          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
	        }
	        return null;
	      } else {
	        return validate(props, propName, componentName, location, propFullName);
	      }
	    }

	    var chainedCheckType = checkType.bind(null, false);
	    chainedCheckType.isRequired = checkType.bind(null, true);

	    return chainedCheckType;
	  }

	  function createPrimitiveTypeChecker(expectedType) {
	    function validate(props, propName, componentName, location, propFullName, secret) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== expectedType) {
	        // `propValue` being instance of, say, date/regexp, pass the 'object'
	        // check, but we can offer a more precise error message here rather than
	        // 'of type `object`'.
	        var preciseType = getPreciseType(propValue);

	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createAnyTypeChecker() {
	    return createChainableTypeChecker(emptyFunction.thatReturnsNull);
	  }

	  function createArrayOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
	      }
	      var propValue = props[propName];
	      if (!Array.isArray(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	      }
	      for (var i = 0; i < propValue.length; i++) {
	        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createElementTypeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      if (!isValidElement(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createInstanceTypeChecker(expectedClass) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!(props[propName] instanceof expectedClass)) {
	        var expectedClassName = expectedClass.name || ANONYMOUS;
	        var actualClassName = getClassName(props[propName]);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createEnumTypeChecker(expectedValues) {
	    if (!Array.isArray(expectedValues)) {
	       true ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
	      return emptyFunction.thatReturnsNull;
	    }

	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      for (var i = 0; i < expectedValues.length; i++) {
	        if (is(propValue, expectedValues[i])) {
	          return null;
	        }
	      }

	      var valuesString = JSON.stringify(expectedValues);
	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createObjectOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
	      }
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	      }
	      for (var key in propValue) {
	        if (propValue.hasOwnProperty(key)) {
	          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	          if (error instanceof Error) {
	            return error;
	          }
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createUnionTypeChecker(arrayOfTypeCheckers) {
	    if (!Array.isArray(arrayOfTypeCheckers)) {
	       true ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
	      return emptyFunction.thatReturnsNull;
	    }

	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (typeof checker !== 'function') {
	        warning(
	          false,
	          'Invalid argument supplid to oneOfType. Expected an array of check functions, but ' +
	          'received %s at index %s.',
	          getPostfixForTypeWarning(checker),
	          i
	        );
	        return emptyFunction.thatReturnsNull;
	      }
	    }

	    function validate(props, propName, componentName, location, propFullName) {
	      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	        var checker = arrayOfTypeCheckers[i];
	        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
	          return null;
	        }
	      }

	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createNodeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!isNode(props[propName])) {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createShapeTypeChecker(shapeTypes) {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	      }
	      for (var key in shapeTypes) {
	        var checker = shapeTypes[key];
	        if (!checker) {
	          continue;
	        }
	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	        if (error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function isNode(propValue) {
	    switch (typeof propValue) {
	      case 'number':
	      case 'string':
	      case 'undefined':
	        return true;
	      case 'boolean':
	        return !propValue;
	      case 'object':
	        if (Array.isArray(propValue)) {
	          return propValue.every(isNode);
	        }
	        if (propValue === null || isValidElement(propValue)) {
	          return true;
	        }

	        var iteratorFn = getIteratorFn(propValue);
	        if (iteratorFn) {
	          var iterator = iteratorFn.call(propValue);
	          var step;
	          if (iteratorFn !== propValue.entries) {
	            while (!(step = iterator.next()).done) {
	              if (!isNode(step.value)) {
	                return false;
	              }
	            }
	          } else {
	            // Iterator will provide entry [k,v] tuples rather than values.
	            while (!(step = iterator.next()).done) {
	              var entry = step.value;
	              if (entry) {
	                if (!isNode(entry[1])) {
	                  return false;
	                }
	              }
	            }
	          }
	        } else {
	          return false;
	        }

	        return true;
	      default:
	        return false;
	    }
	  }

	  function isSymbol(propType, propValue) {
	    // Native Symbol.
	    if (propType === 'symbol') {
	      return true;
	    }

	    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
	    if (propValue['@@toStringTag'] === 'Symbol') {
	      return true;
	    }

	    // Fallback for non-spec compliant Symbols which are polyfilled.
	    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
	      return true;
	    }

	    return false;
	  }

	  // Equivalent of `typeof` but with special handling for array and regexp.
	  function getPropType(propValue) {
	    var propType = typeof propValue;
	    if (Array.isArray(propValue)) {
	      return 'array';
	    }
	    if (propValue instanceof RegExp) {
	      // Old webkits (at least until Android 4.0) return 'function' rather than
	      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	      // passes PropTypes.object.
	      return 'object';
	    }
	    if (isSymbol(propType, propValue)) {
	      return 'symbol';
	    }
	    return propType;
	  }

	  // This handles more types than `getPropType`. Only used for error messages.
	  // See `createPrimitiveTypeChecker`.
	  function getPreciseType(propValue) {
	    if (typeof propValue === 'undefined' || propValue === null) {
	      return '' + propValue;
	    }
	    var propType = getPropType(propValue);
	    if (propType === 'object') {
	      if (propValue instanceof Date) {
	        return 'date';
	      } else if (propValue instanceof RegExp) {
	        return 'regexp';
	      }
	    }
	    return propType;
	  }

	  // Returns a string that is postfixed to a warning about an invalid type.
	  // For example, "undefined" or "of type array"
	  function getPostfixForTypeWarning(value) {
	    var type = getPreciseType(value);
	    switch (type) {
	      case 'array':
	      case 'object':
	        return 'an ' + type;
	      case 'boolean':
	      case 'date':
	      case 'regexp':
	        return 'a ' + type;
	      default:
	        return type;
	    }
	  }

	  // Returns class name of the object, if any.
	  function getClassName(propValue) {
	    if (!propValue.constructor || !propValue.constructor.name) {
	      return ANONYMOUS;
	    }
	    return propValue.constructor.name;
	  }

	  ReactPropTypes.checkPropTypes = checkPropTypes;
	  ReactPropTypes.PropTypes = ReactPropTypes;

	  return ReactPropTypes;
	};


/***/ }),
/* 32 */
/***/ (function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	// If obj.hasOwnProperty has been overridden, then calling
	// obj.hasOwnProperty(prop) will break.
	// See: https://github.com/joyent/node/issues/1707
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	module.exports = function(qs, sep, eq, options) {
	  sep = sep || '&';
	  eq = eq || '=';
	  var obj = {};

	  if (typeof qs !== 'string' || qs.length === 0) {
	    return obj;
	  }

	  var regexp = /\+/g;
	  qs = qs.split(sep);

	  var maxKeys = 1000;
	  if (options && typeof options.maxKeys === 'number') {
	    maxKeys = options.maxKeys;
	  }

	  var len = qs.length;
	  // maxKeys <= 0 means that we should not limit keys count
	  if (maxKeys > 0 && len > maxKeys) {
	    len = maxKeys;
	  }

	  for (var i = 0; i < len; ++i) {
	    var x = qs[i].replace(regexp, '%20'),
	        idx = x.indexOf(eq),
	        kstr, vstr, k, v;

	    if (idx >= 0) {
	      kstr = x.substr(0, idx);
	      vstr = x.substr(idx + 1);
	    } else {
	      kstr = x;
	      vstr = '';
	    }

	    k = decodeURIComponent(kstr);
	    v = decodeURIComponent(vstr);

	    if (!hasOwnProperty(obj, k)) {
	      obj[k] = v;
	    } else if (Array.isArray(obj[k])) {
	      obj[k].push(v);
	    } else {
	      obj[k] = [obj[k], v];
	    }
	  }

	  return obj;
	};


/***/ }),
/* 33 */
/***/ (function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	var stringifyPrimitive = function(v) {
	  switch (typeof v) {
	    case 'string':
	      return v;

	    case 'boolean':
	      return v ? 'true' : 'false';

	    case 'number':
	      return isFinite(v) ? v : '';

	    default:
	      return '';
	  }
	};

	module.exports = function(obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }

	  if (typeof obj === 'object') {
	    return Object.keys(obj).map(function(k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (Array.isArray(obj[k])) {
	        return obj[k].map(function(v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);

	  }

	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq +
	         encodeURIComponent(stringifyPrimitive(obj));
	};


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.decode = exports.parse = __webpack_require__(32);
	exports.encode = exports.stringify = __webpack_require__(33);


/***/ })
/******/ ])
});
;